<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Slots</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1622;
      --panel2:#0c111a;
      --border:rgba(255,255,255,.08);
      --text:#e7eefc;
      --muted:rgba(231,238,252,.65);
      --accent:#7c3aed;
      --accent2:#22d3ee;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 700px at 20% 0%, rgba(124,58,237,.18), transparent 50%),
        radial-gradient(1000px 600px at 90% 10%, rgba(34,211,238,.12), transparent 55%),
        var(--bg);
      color: var(--text);
    }
    button{ font-family:inherit; }
    .wrap{ max-width:1200px; margin:0 auto; padding: 18px 16px 32px; }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap: 12px; padding: 16px;
      background: rgba(15,22,34,.7);
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      position: sticky; top: 10px; z-index: 10;
    }
    .brand{ display:flex; align-items:center; gap:12px; cursor:pointer; }
    .logo{
      width: 42px; height: 42px; border-radius: 14px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 8px 25px rgba(124,58,237,.25);
      position: relative; overflow:hidden;
    }
    .logo:after{
      content:""; position:absolute; inset:-40%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), transparent 45%);
      transform: rotate(20deg);
    }
    .brand h1{ margin:0; font-size: 20px; letter-spacing:.4px; }
    .brand .sub{ margin-top:2px; font-size:12px; color: var(--muted); }

    .right{ display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap; }
    .statbar{
      display:flex; gap:10px; align-items:center;
      padding: 10px 12px; border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(12,17,26,.7);
      color: var(--muted); font-size: 12px; white-space: nowrap;
    }
    .statbar b{ color: var(--text); font-weight: 800; font-family: var(--mono); }

    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:10px;
      padding: 11px 12px; border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(12,17,26,.7);
      color: var(--text); cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      font-weight: 800; font-size: 13px;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.16); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(124,58,237,.85), rgba(34,211,238,.55));
      border-color: rgba(124,58,237,.35);
    }
    .btn:disabled{ opacity:.45; cursor:not-allowed; transform:none !important; }

    .subbar{
      margin-top: 14px; padding: 12px;
      background: rgba(15,22,34,.55);
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px; flex-wrap: wrap;
    }
    .tabs{ display:flex; gap:8px; align-items:center; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 10px 12px; border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(12,17,26,.7);
      color: var(--muted);
      cursor: pointer; user-select:none;
      transition: transform .06s ease, background .2s ease, border-color .2s ease, color .2s ease;
      font-weight: 800; font-size: 13px;
    }
    .pill:hover{ transform: translateY(-1px); color: var(--text); border-color: rgba(255,255,255,.14); }
    .pill.active{
      background: linear-gradient(135deg, rgba(124,58,237,.18), rgba(34,211,238,.12));
      border-color: rgba(124,58,237,.35);
      color: var(--text);
    }
    .subActions{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hint{ color: var(--muted); font-size: 13px; }

    .grid{ display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 12px; margin-top: 12px; }
    @media (max-width: 1100px){ .grid{ grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 820px){ .grid{ grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 520px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      background: rgba(15,22,34,.72);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex; flex-direction:column;
      min-height: 250px;
      transition: transform .08s ease, border-color .2s ease;
      cursor:pointer;
    }
    .card:hover{ transform: translateY(-2px); border-color: rgba(255,255,255,.16); }

    .thumb{
      height: 120px;
      background: linear-gradient(135deg, rgba(124,58,237,.28), rgba(34,211,238,.14));
      border-bottom: 1px solid var(--border);
      display:flex; align-items:center; justify-content:center;
      position: relative;
    }
    .thumb .ph{
      width: 62px; height: 62px; border-radius: 18px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      display:flex; align-items:center; justify-content:center;
      font-weight: 900; letter-spacing: .8px;
      color: rgba(231,238,252,.75);
    }
    .badge{
      position:absolute; top: 10px; left: 10px;
      display:inline-flex; align-items:center; gap:6px;
      padding: 6px 10px; border-radius: 999px;
      font-size: 12px; font-weight: 900;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(12,17,26,.62);
      color: var(--text);
      backdrop-filter: blur(8px);
    }
    .badge.locked{ border-color: rgba(245,158,11,.28); color: #ffe7c2; background: rgba(245,158,11,.10); }
    .badge.unlocked{ border-color: rgba(34,197,94,.26); color: #d4ffdf; background: rgba(34,197,94,.10); }

    .cardbody{ padding: 12px; display:flex; flex-direction:column; gap: 8px; flex: 1; }
    .name{
      font-weight: 900; letter-spacing: .2px;
      font-size: 14px; line-height: 1.15;
      display:flex; align-items:center; justify-content:space-between; gap: 8px;
    }
    .meta{ display:flex; justify-content:space-between; align-items:center; gap: 10px; color: var(--muted); font-size: 12px; }
    .price{ font-family: var(--mono); font-weight: 900; color: var(--text); }
    .votes{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; font-size: 12px; color: var(--muted); }
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding: 6px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(12,17,26,.60);
    }
    .chip .up{ color: rgba(34,197,94,.95); font-weight: 900; }
    .chip .down{ color: rgba(239,68,68,.95); font-weight: 900; }
    .chip .net{ color: rgba(231,238,252,.85); font-weight: 900; }

    .actions{ display:flex; gap: 8px; margin-top:auto; }
    .mini{
      flex: 1;
      padding: 9px 10px; border-radius: 12px;
      font-size: 12px; font-weight: 900;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(12,17,26,.55);
      color: var(--text);
      cursor:pointer;
      transition: transform .06s ease, border-color .2s ease;
    }
    .mini:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.18); }
    .mini.up{ border-color: rgba(34,197,94,.22); }
    .mini.down{ border-color: rgba(239,68,68,.22); }
    .mini.buy{ opacity:.45; cursor:not-allowed; }

    .detail{ margin-top: 14px; display:grid; grid-template-columns: 1.15fr .85fr; gap: 14px; }
    @media (max-width: 900px){ .detail{ grid-template-columns: 1fr; } }

    .panel{
      background: rgba(15,22,34,.72);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHead{
      padding: 14px;
      border-bottom: 1px solid var(--border);
      display:flex; align-items:flex-start; justify-content:space-between;
      gap: 10px; flex-wrap: wrap;
    }
    .panelHead h2{ margin:0; font-size: 18px; letter-spacing:.2px; }
    .panelHead .sub{ margin-top:4px; font-size:12px; color: var(--muted); font-family: var(--mono); }
    .panelBody{ padding: 14px; }

    .bigThumb{
      height: 220px;
      background: linear-gradient(135deg, rgba(124,58,237,.28), rgba(34,211,238,.14));
      border-bottom: 1px solid var(--border);
      display:flex; align-items:center; justify-content:center;
      position: relative;
    }
    .bigThumb .ph{
      width: 96px; height: 96px; border-radius: 26px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      display:flex; align-items:center; justify-content:center;
      font-weight: 900; letter-spacing: 1px;
      color: rgba(231,238,252,.75);
      font-size: 24px;
    }
    .kv{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 12px; }
    .kv .box{
      padding: 12px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(12,17,26,.55);
    }
    .kv .label{ font-size:12px; color:var(--muted); margin-bottom:6px; font-weight:900; }
    .kv .value{ font-family: var(--mono); font-weight: 900; font-size: 14px; }

    .list{ display:flex; flex-direction:column; gap: 8px; max-height: 340px; overflow:auto; padding-right: 4px; }
    .row{
      padding: 10px 12px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(12,17,26,.55);
      display:flex; justify-content:space-between; align-items:center;
      gap: 10px; font-size: 12px; color: var(--muted);
    }
    .row b{ color: var(--text); }
    .row .tagUp{ color: rgba(34,197,94,.95); font-weight: 900; }
    .row .tagDown{ color: rgba(239,68,68,.95); font-weight: 900; }

    .graphWrap{
      margin-top: 12px; padding: 12px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(12,17,26,.55);
    }
    .graphTitle{ font-weight:900; margin-bottom:8px; }
    svg{ display:block; width:100%; height:140px; }
    .note{ color: var(--muted); font-size: 12px; margin-top: 10px; line-height:1.4; }
  </style>

  <!-- TweetNaCl for Phantom mobile deeplink encryption/decryption -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tweetnacl/1.0.2/nacl-fast.min.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand" onclick="goHome()">
        <div class="logo"></div>
        <div>
          <h1>Slots</h1>
          <div class="sub">Prototype (Phantom desktop + mobile • SOL balance)</div>
        </div>
      </div>

      <div class="right">
        <div class="statbar" id="walletBar">
          Wallet: <b id="walletShort">—</b> • SOL: <b id="walletSol">—</b> • SLOTS(fake): <b id="walletFake">—</b>
        </div>
        <button class="btn" id="btnRefresh" onclick="refreshSol()" disabled>Refresh SOL</button>
        <button class="btn primary" id="btnConnect" onclick="connectWallet()">Connect wallet</button>
      </div>
    </div>

    <div class="subbar">
      <div class="tabs">
        <div class="pill active" id="tabTrending" onclick="setView('trending', event)">Trending</div>
        <div class="pill" id="tabNew" onclick="setView('new', event)">New</div>
      </div>

      <div class="subActions">
        <button class="btn" id="btnCreate" onclick="openCreateModal(event)" disabled>Create slot</button>
        <button class="btn" id="btnMy" onclick="setView('my', event)" disabled>My slots</button>
      </div>
    </div>

    <div class="content" id="content"></div>
  </div>

<script>
/** -----------------------------
 * State
 * ----------------------------- */
const state = {
  view: 'trending',
  selectedId: null,

  wallet: {
    connected: false,
    pubkey: null,
    sol: null,
    fake: null
  },

  model: {
    floorUSD: 5,
    p: 1.50,
    k: 0.0315,
    refSec: 1.0,
    beta: 0.50,
    wMin: 0.20,
    wMax: 3.00
  },

  slots: [],
  sim: { tickMs: 250 }
};

function now(){ return Date.now(); }
function fmtMoney(n){
  const x = Math.max(0, n || 0);
  return '$' + x.toFixed(x >= 1000 ? 0 : (x >= 100 ? 1 : 2));
}
function fmtSol(n){
  if(n === null || n === undefined) return '—';
  return (Math.round(n * 1000) / 1000).toFixed(3);
}
function fmtFake(n){
  if(n === null || n === undefined) return '—';
  const x = Number(n);
  if(!isFinite(x)) return '—';
  return x.toFixed(2);
}
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randHex(len){
  const chars = 'abcdef0123456789';
  let s='';
  for(let i=0;i<len;i++) s += chars[Math.floor(Math.random()*chars.length)];
  return s;
}
function shortAddr(a){ return a ? (a.slice(0,4) + '…' + a.slice(-4)) : '—'; }
function escapeHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, m => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'
  }[m]));
}

/** -----------------------------
 * Minimal Base58 + Base64URL helpers
 * ----------------------------- */
const BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const BASE58_MAP = (() => {
  const m = new Map();
  for (let i=0;i<BASE58_ALPHABET.length;i++) m.set(BASE58_ALPHABET[i], i);
  return m;
})();
function b58encode(bytes){
  if(!(bytes instanceof Uint8Array)) bytes = new Uint8Array(bytes);
  if(bytes.length === 0) return "";
  let zeros = 0;
  while (zeros < bytes.length && bytes[zeros] === 0) zeros++;

  const digits = [0];
  for (let i=zeros;i<bytes.length;i++){
    let carry = bytes[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j] * 256 + carry;
      digits[j] = x % 58;
      carry = (x / 58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry / 58) | 0;
    }
  }
  let out = "1".repeat(zeros);
  for (let i=digits.length-1;i>=0;i--) out += BASE58_ALPHABET[digits[i]];
  return out;
}
function b58decode(str){
  if(!str) return new Uint8Array();
  let zeros = 0;
  while (zeros < str.length && str[zeros] === "1") zeros++;

  const bytes = [0];
  for (let i=zeros;i<str.length;i++){
    const val = BASE58_MAP.get(str[i]);
    if(val === undefined) throw new Error("Invalid base58 char");
    let carry = val;
    for (let j=0;j<bytes.length;j++){
      const x = bytes[j] * 58 + carry;
      bytes[j] = x & 0xff;
      carry = x >> 8;
    }
    while (carry){
      bytes.push(carry & 0xff);
      carry >>= 8;
    }
  }
  for (let k=0;k<zeros;k++) bytes.push(0);
  bytes.reverse();
  return new Uint8Array(bytes);
}
function bytesToB64(bytes){
  let s = "";
  for (let i=0;i<bytes.length;i++) s += String.fromCharCode(bytes[i]);
  return btoa(s);
}
function b64ToBytes(b64){
  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
  return out;
}
function b64UrlToBytes(s){
  let b64 = s.replace(/-/g, "+").replace(/_/g, "/");
  while (b64.length % 4) b64 += "=";
  return b64ToBytes(b64);
}
function decodeAny(str){
  try { return b58decode(str); } catch(_e) {}
  return b64UrlToBytes(str);
}

/** -----------------------------
 * Solana RPC
 * ----------------------------- */
const RPC_URLS = [
  "https://rpc.ankr.com/solana",
  "https://solana.publicnode.com",
  "https://api.mainnet-beta.solana.com"
];

async function solanaRpc(method, params){
  let lastErr = null;

  for (const url of RPC_URLS){
    try{
      const res = await fetch(url, {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
      });

      if(!res.ok){
        throw new Error(`RPC HTTP ${res.status} on ${url}`);
      }

      const json = await res.json();
      if(json.error) throw new Error(json.error.message || "RPC error");
      return json.result;
    }catch(e){
      lastErr = e;
      console.warn("RPC failed:", url, e);
    }
  }

  throw lastErr || new Error("All RPC endpoints failed");
}

async function fetchSolBalance(pubkey){
  const result = await solanaRpc("getBalance", [pubkey, { commitment: "confirmed" }]);
  const lamports = result?.value ?? 0;
  return lamports / 1_000_000_000;
}

async function refreshSol(){
  if(!state.wallet.connected || !state.wallet.pubkey) return;
  try{
    const sol = await fetchSolBalance(state.wallet.pubkey);
    state.wallet.sol = sol;
    renderTop();
  }catch(err){
    console.error("SOL balance fetch error:", err);
    state.wallet.sol = null;
    renderTop();
    alert("Connected, but couldn't fetch SOL balance (RPC issue).");
  }
}

/** -----------------------------
 * Backend login + fake balance
 * ----------------------------- */
async function refreshBackendUser(){
  try{
    const r = await fetch("/api/me2", { credentials: "include" });
    const me = await r.json();
    if(me && me.ok && me.user){
      state.wallet.fake = me.user.fake_balance;
    } else {
      state.wallet.fake = null;
    }
    renderTop();
  }catch(_e){
    state.wallet.fake = null;
    renderTop();
  }
}

async function loginToBackend(){
  if(!state.wallet.connected || !state.wallet.pubkey) return;

  // If already logged in, this should populate fake balance
  await refreshBackendUser();
  if(state.wallet.fake !== null && state.wallet.fake !== undefined) return;

  // Desktop-only for message signing in this prototype
  if(!(window.solana && window.solana.isPhantom && window.solana.signMessage)){
    return;
  }

  // 1) challenge
  const chRes = await fetch("/api/auth/challenge", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    credentials: "include",
    body: JSON.stringify({ wallet: state.wallet.pubkey })
  });
  const ch = await chRes.json();
  if(ch.error) return;

  // 2) sign message
  const msgBytes = new TextEncoder().encode(ch.message);
  const signed = await window.solana.signMessage(msgBytes, "utf8");

  // 3) signature base58
  const sigB58 = b58encode(signed.signature);

  // 4) verify (sets httpOnly cookie)
  const vRes = await fetch("/api/auth/verify", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    credentials: "include",
    body: JSON.stringify({ wallet: state.wallet.pubkey, nonce: ch.nonce, signature: sigB58 })
  });
  const v = await vRes.json();
  if(v.error) return;

  // 5) read user
  await refreshBackendUser();
}

/** -----------------------------
 * Phantom Desktop + Mobile Connect
 * ----------------------------- */
function isMobile(){
  return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent || "");
}

function setConnected(pubkey){
  state.wallet.connected = true;
  state.wallet.pubkey = pubkey;

  document.getElementById("btnConnect").textContent = "Wallet connected";
  document.getElementById("btnConnect").disabled = true;

  document.getElementById("btnRefresh").disabled = false;
  document.getElementById("btnCreate").disabled = false;
  document.getElementById("btnMy").disabled = false;

  renderTop();
}

/** -----------------------------
 * DESKTOP SILENT RECONNECT (SESSION ONLY)
 * ----------------------------- */
const SILENT_FLAG_KEY = "SLOTS_CAN_SILENT";

function markSilentAllowedThisTab(){
  try { sessionStorage.setItem(SILENT_FLAG_KEY, "1"); } catch(_e){}
}
function canSilentThisTab(){
  try { return sessionStorage.getItem(SILENT_FLAG_KEY) === "1"; } catch(_e){ return false; }
}

async function trySilentReconnect(){
  if(!canSilentThisTab()) return;
  if (!(window.solana && window.solana.isPhantom)) return;

  try{
    const resp = await window.solana.connect({ onlyIfTrusted: true });
    if(resp && resp.publicKey){
      const pubkey = resp.publicKey.toString();
      setConnected(pubkey);
      await refreshSol();
      await loginToBackend();
    }
  }catch(_e){}
}

function clearMobileLinkParams(){
  const url = new URL(window.location.href);
  ["phantom_encryption_public_key","nonce","data","errorCode","errorMessage","state","_phantom","_t"].forEach(k => url.searchParams.delete(k));
  window.history.replaceState({}, "", url.toString());
}

function makeStateId(){
  return `${Date.now()}_${Math.random().toString(16).slice(2)}_${Math.random().toString(16).slice(2)}`;
}

/* ✅ FIX: make async (so the awaits don’t crash the whole file) */
async function handlePhantomMobileRedirect(){
  const url = new URL(window.location.href);

  const errCode = url.searchParams.get("errorCode");
  const errMsg = url.searchParams.get("errorMessage");
  if(errCode){
    clearMobileLinkParams();
    alert(`Phantom rejected: ${errMsg || errCode}`);
    return;
  }

  const phantomPub = url.searchParams.get("phantom_encryption_public_key");
  const nonce = url.searchParams.get("nonce");
  const data = url.searchParams.get("data");
  const st = url.searchParams.get("state");

  if(!phantomPub || !nonce || !data || !st) return;

  try{
    const stored = localStorage.getItem(`PHANTOM_MOBILE_SESSION_${st}`);
    if(!stored) throw new Error("Missing mobile session. Tap connect again.");
    localStorage.removeItem(`PHANTOM_MOBILE_SESSION_${st}`);

    const { dappSecretKeyB64 } = JSON.parse(stored);
    const dappSecretKey = b64ToBytes(dappSecretKeyB64);

    const phantomPubBytes = decodeAny(phantomPub);
    const nonceBytes = decodeAny(nonce);
    const dataBytes = decodeAny(data);

    const sharedSecret = nacl.box.before(phantomPubBytes, dappSecretKey);
    const decrypted = nacl.box.open.after(dataBytes, nonceBytes, sharedSecret);
    if(!decrypted) throw new Error("Failed to decrypt Phantom payload.");

    const jsonStr = new TextDecoder().decode(decrypted);
    const payload = JSON.parse(jsonStr);

    if(!payload.public_key) throw new Error("No public_key in Phantom payload.");

    setConnected(payload.public_key);

    clearMobileLinkParams();
    await refreshSol();
    // backend login (signMessage) desktop-only for now
  }catch(e){
    console.error(e);
    clearMobileLinkParams();
    alert("Mobile connect failed. Tap connect again.");
  }
}

function startPhantomMobileConnect(){
  const dappKeyPair = nacl.box.keyPair();
  const dappPublicKey = dappKeyPair.publicKey;
  const dappSecretKey = dappKeyPair.secretKey;

  const st = makeStateId();
  localStorage.setItem(`PHANTOM_MOBILE_SESSION_${st}`, JSON.stringify({
    dappSecretKeyB64: bytesToB64(dappSecretKey),
    createdAt: Date.now()
  }));

  const appUrl = window.location.origin;

  const redirect = new URL(window.location.href);
  redirect.searchParams.set("_phantom", "1");
  redirect.searchParams.set("_t", String(Date.now()));
  redirect.searchParams.set("state", st);

  const params = new URLSearchParams();
  params.set("app_url", appUrl);
  params.set("dapp_encryption_public_key", b58encode(dappPublicKey));
  params.set("redirect_link", redirect.toString());
  params.set("cluster", "mainnet-beta");
  params.set("state", st);

  const deeplink = `https://phantom.app/ul/v1/connect?${params.toString()}`;
  window.location.href = deeplink;
}

async function connectWallet(){
  if(window.solana && window.solana.isPhantom){
    try{
      const resp = await window.solana.connect();
      const pubkey = resp.publicKey.toString();
      setConnected(pubkey);

      markSilentAllowedThisTab();

      await refreshSol();
      await loginToBackend();
      return;
    }catch(err){
      console.error("Desktop Phantom connect error:", err);
      alert("Wallet connection failed.");
      return;
    }
  }

  if(isMobile()){
    startPhantomMobileConnect();
    return;
  }

  alert("Phantom not detected. Install Phantom extension (desktop) or Phantom app (mobile).");
}

function renderTop(){
  document.getElementById('walletShort').textContent = shortAddr(state.wallet.pubkey);
  document.getElementById('walletSol').textContent =
    state.wallet.connected ? (state.wallet.sol === 0 ? "0.000" : fmtSol(state.wallet.sol)) : '—';
  document.getElementById('walletFake').textContent =
    state.wallet.connected ? fmtFake(state.wallet.fake) : '—';
}

/** -----------------------------
 * Slot simulation (unchanged)
 * ----------------------------- */
const nameA = ["Neon","Turbo","Ghost","Violet","Chrome","Solar","Apex","Shadow","Feral","Nova","Glitch","Pixel","Hyper","Omega","Void","Mint","Lunar","Prism","Rogue","Flux"];
const nameB = ["Trump","Wizard","Monkey","Whale","Cat","Pepe","Rocket","Goblin","Knight","Alien","Dragon","Degen","Reaper","Angel","Bot","King","Queen","Titan","Hacker","Joker"];
const nameC = ["Protocol","Poster","Slot","Board","Cannon","Machine","Signal","Hype","Wave","Engine","Temple","Arena","Mint","Market","Scroll","Portal","Gem","Grail","Relay","Index"];
function makeName(){ return `${randChoice(nameA)} ${randChoice(nameB)} ${randChoice(nameC)}`; }

function newSlot(id, creatorWallet, createdAt){
  const r = Math.random();
  let rate;
  if (r < 0.06) rate = randInt(6, 10);
  else if (r < 0.20) rate = (Math.random()*3)+2;
  else if (r < 0.70) rate = (Math.random()*1.8)+0.2;
  else rate = (Math.random()*0.25)+0.02;

  const locked = Math.random() < 0.22;
  const lockMs = locked ? randInt(60, 360) * 1000 : 0;

  const startT = createdAt ?? now();

  return {
    id,
    name: makeName(),
    createdAt: startT,
    creatorWallet: creatorWallet ?? null,
    ownerWallet: creatorWallet ?? `BOT_${randHex(6)}`,
    lockedUntil: locked ? (now() + lockMs) : 0,

    votes: [],
    sales: [],
    priceHistory: [{ t: startT, priceUSD: 5 }],

    up: 0,
    down: 0,
    scoreS: 0,
    priceUSD: 5,
    lastVoteAt: startT,

    voteRatePerSec: rate
  };
}

function initSlots(){
  const base = [];
  for(let i=1;i<=100;i++){
    const createdAt = now() - randInt(0, 6*60*60*1000);
    base.push(newSlot(i, null, createdAt));
  }
  state.slots = base;
}

function computePriceFromScore(S){
  const {floorUSD, k, p} = state.model;
  const x = Math.max(0, S);
  return Math.max(floorUSD, floorUSD + k * Math.pow(x, p));
}
function voteWeightFromDeltaSec(dtSec){
  const {refSec, beta, wMin, wMax} = state.model;
  const safe = Math.max(0.05, dtSec);
  let w = Math.pow(refSec / safe, beta);
  if(!isFinite(w)) w = wMax;
  return Math.max(wMin, Math.min(wMax, w));
}
function pushPriceHistory(slot, price){
  const t = now();
  slot.priceHistory.push({ t, priceUSD: price });
  if(slot.priceHistory.length > 300){
    slot.priceHistory.splice(0, slot.priceHistory.length - 300);
  }
}
function isLocked(slot){ return slot.lockedUntil && slot.lockedUntil > now(); }

function applyVote(slot, v, wallet){
  const t = now();
  const dtSec = Math.max(0.001, (t - (slot.lastVoteAt || slot.createdAt)) / 1000);
  const w = voteWeightFromDeltaSec(dtSec);

  slot.lastVoteAt = t;
  slot.votes.push({ t, wallet, v, w });

  if(v > 0) slot.up++;
  else slot.down++;

  slot.scoreS += v * w;
  slot.priceUSD = computePriceFromScore(slot.scoreS);
  pushPriceHistory(slot, slot.priceUSD);
}

function castVote(slotId, v, e){
  if(e) e.stopPropagation();
  const slot = state.slots.find(s => s.id === slotId);
  if(!slot) return;

  const w = state.wallet.connected ? state.wallet.pubkey : `BOT_${randHex(6)}`;
  applyVote(slot, v, w);
  render(false);
}

function openCreateModal(e){
  if(e) e.stopPropagation();
  if(!state.wallet.connected){
    alert("Connect Phantom first.");
    return;
  }
  const cost = 20;
  const ok = confirm(`Create slot (prototype). Cost: $${cost} (not real). Continue?`);
  if(!ok) return;
  createSlot();
}

function createSlot(){
  const newId = Math.max(...state.slots.map(s=>s.id)) + 1;
  const slot = newSlot(newId, state.wallet.pubkey, now());
  slot.creatorWallet = state.wallet.pubkey;
  slot.ownerWallet = state.wallet.pubkey;
  slot.priceUSD = 5;
  slot.scoreS = 0;
  slot.lockedUntil = now() + 2 * 60 * 1000;

  state.slots.unshift(slot);
  setView('new');
  render();
}

function simTick(){
  const dtSec = state.sim.tickMs / 1000;

  for(const slot of state.slots){
    const expected = slot.voteRatePerSec * dtSec;
    let nVotes = 0;

    if(expected < 0.35){
      if(Math.random() < expected) nVotes = 1;
    } else {
      const whole = Math.floor(expected);
      const frac = expected - whole;
      nVotes += whole;
      if(Math.random() < frac) nVotes += 1;
      if(Math.random() < Math.min(0.08, expected*0.02)) nVotes += randInt(1,3);
    }

    for(let i=0;i<nVotes;i++){
      const v = (Math.random() < 0.56) ? +1 : -1;
      const w = `BOT_${randHex(6)}`;
      applyVote(slot, v, w);
    }
  }

  render(false);
}
let simHandle = null;
function startSim(){
  if(simHandle) clearInterval(simHandle);
  simHandle = setInterval(simTick, state.sim.tickMs);
}

function setView(v, e){
  if(e) e.stopPropagation();
  state.view = v;
  state.selectedId = null;

  document.getElementById('tabTrending').classList.toggle('active', v === 'trending');
  document.getElementById('tabNew').classList.toggle('active', v === 'new');

  render();
}
function goHome(){
  state.selectedId = null;
  state.view = 'trending';
  document.getElementById('tabTrending').classList.add('active');
  document.getElementById('tabNew').classList.remove('active');
  render();
}
function openDetail(id){
  state.selectedId = id;
  state.view = 'detail';
  render();
}

function rankSlotsTrending(){
  return [...state.slots].sort((a,b)=>{
    if(b.scoreS !== a.scoreS) return b.scoreS - a.scoreS;
    const nb = (b.up - b.down), na = (a.up - a.down);
    if(nb !== na) return nb - na;
    return b.createdAt - a.createdAt;
  });
}
function rankSlotsNew(){
  return [...state.slots].sort((a,b)=> b.createdAt - a.createdAt);
}
function getMySlots(){
  if(!state.wallet.connected) return [];
  const w = state.wallet.pubkey;
  return state.slots.filter(s => s.creatorWallet === w || s.ownerWallet === w)
    .sort((a,b)=> b.createdAt - a.createdAt);
}

function render(){
  const root = document.getElementById('content');

  if(state.selectedId){
    root.innerHTML = renderDetail(state.selectedId);
    return;
  }

  let list = [];
  if(state.view === 'new') list = rankSlotsNew();
  else if(state.view === 'my') list = getMySlots();
  else list = rankSlotsTrending();

  root.innerHTML = `
    <div class="hint">Showing ${list.length} slots</div>
    <div class="grid">
      ${list.map((s, idx)=> renderCard(s, state.view === 'trending' ? (idx+1) : null)).join('')}
    </div>
    <div class="note">Buy is disabled in this version (no smart contracts yet).</div>
  `;

  for(const s of list){
    const el = document.getElementById(\`card_\${s.id}\`);
    if(el){
      el.addEventListener('click', ()=> openDetail(s.id));
    }
  }
}

function renderCard(s, rank){
  const locked = isLocked(s);
  const net = s.up - s.down;
  const badgeCls = locked ? 'locked' : 'unlocked';
  const badgeText = locked ? 'LOCKED' : 'UNLOCKED';
  const lockHint = locked ? \`• until \${new Date(s.lockedUntil).toLocaleTimeString()}\` : '';

  return `
    <div class="card" id="card_${s.id}">
      <div class="thumb">
        <div class="badge ${badgeCls}">${badgeText} ${lockHint}</div>
        <div class="ph">S${s.id}</div>
      </div>
      <div class="cardbody">
        <div class="name">
          <span>${escapeHtml(s.name)}</span>
          ${rank ? `<span style="color:var(--muted); font-family:var(--mono); font-size:12px;">#${rank}</span>` : ``}
        </div>

        <div class="meta">
          <div>Owner: <span style="font-family:var(--mono)">${escapeHtml(shortAddr(s.ownerWallet.startsWith('BOT_') ? 'So1a1111111111111111111111111111111111111' : s.ownerWallet))}</span></div>
          <div class="price">${fmtMoney(s.priceUSD)}</div>
        </div>

        <div class="votes">
          <span class="chip"><span class="up">▲</span> ${s.up}</span>
          <span class="chip"><span class="down">▼</span> ${s.down}</span>
          <span class="chip"><span class="net">Net</span> ${net}</span>
        </div>

        <div class="actions">
          <button class="mini up" onclick="castVote(${s.id}, +1, event)">▲ Up</button>
          <button class="mini down" onclick="castVote(${s.id}, -1, event)">▼ Down</button>
          <button class="mini buy" disabled title="Disabled (no smart contracts yet)">Buy</button>
        </div>
      </div>
    </div>
  `;
}

function renderDetail(id){
  const s = state.slots.find(x => x.id === id);
  if(!s) return `<div class="panel"><div class="panelBody">Slot not found.</div></div>`;

  const locked = isLocked(s);
  const net = s.up - s.down;

  const votes = [...s.votes].slice(-80).reverse();
  const graphSvg = renderPriceGraphSvg(s.priceHistory);

  return `
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
      <button class="btn" onclick="goHome()">← Back</button>
      <div class="statbar">
        Slot <b>#${s.id}</b> • ${locked ? '<b style="color:#ffe7c2;">Locked</b>' : '<b style="color:#d4ffdf;">Unlocked</b>'}
        ${locked ? `• ends ${new Date(s.lockedUntil).toLocaleTimeString()}` : ''}
      </div>
    </div>

    <div class="detail">
      <div class="panel">
        <div class="bigThumb">
          <div class="badge ${locked ? 'locked' : 'unlocked'}">${locked ? 'LOCKED' : 'UNLOCKED'}</div>
          <div class="ph">S${s.id}</div>
        </div>

        <div class="panelHead">
          <div>
            <h2>${escapeHtml(s.name)}</h2>
            <div class="sub">Created: ${new Date(s.createdAt).toLocaleString()}</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <button class="btn" onclick="castVote(${s.id}, +1, event)">▲ Upvote</button>
            <button class="btn" style="background: rgba(239,68,68,.12); border-color: rgba(239,68,68,.25);" onclick="castVote(${s.id}, -1, event)">▼ Downvote</button>
            <button class="btn" disabled title="Disabled (no smart contracts yet)">Buy</button>
          </div>
        </div>

        <div class="panelBody">
          <div class="kv">
            <div class="box">
              <div class="label">Current price</div>
              <div class="value">${fmtMoney(s.priceUSD)}</div>
            </div>
            <div class="box">
              <div class="label">Votes</div>
              <div class="value">▲ ${s.up}  ▼ ${s.down}  • Net ${net}</div>
            </div>
          </div>

          <div class="graphWrap">
            <div class="graphTitle">Price history</div>
            ${graphSvg}
          </div>

          <div style="margin-top: 12px;">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 8px;">
              <div style="font-weight:900;">Recent votes</div>
              <div style="color:var(--muted); font-size:12px;">(last ${Math.min(80, s.votes.length)})</div>
            </div>
            <div class="list">
              ${votes.length ? votes.map(v=>`
                <div class="row">
                  <div><b style="font-family:var(--mono)">${escapeHtml(shortAddr(v.wallet))}</b></div>
                  <div>${new Date(v.t).toLocaleTimeString()} • <span class="${v.v>0?'tagUp':'tagDown'}">${v.v>0?'▲ UP':'▼ DOWN'}</span></div>
                </div>
              `).join('') : `<div class="row">No votes yet.</div>`}
            </div>
          </div>

          <div class="note">Sales/buyouts are disabled until smart contracts are added.</div>
        </div>
      </div>

      <div class="panel">
        <div class="panelHead">
          <div>
            <h2>Notes</h2>
            <div class="sub">Testing only</div>
          </div>
        </div>
        <div class="panelBody" style="color:var(--muted); font-size:13px; line-height:1.5;">
          Phantom connect works on desktop + mobile. Slots/votes/prices are simulated/off-chain.
        </div>
      </div>
    </div>
  `;
}

function renderPriceGraphSvg(history){
  const data = (history || []).slice(-120);
  const w = 640, h = 140, pad = 10;

  if(data.length < 2){
    return `<div style="color:var(--muted); font-size:12px;">Not enough data yet…</div>`;
  }

  const prices = data.map(d => d.priceUSD);
  let min = Math.min(...prices);
  let max = Math.max(...prices);
  if(max - min < 0.0001){ max = min + 1; }

  const xStep = (w - pad*2) / (data.length - 1);
  const pts = data.map((d,i)=>{
    const x = pad + i * xStep;
    const y = pad + (h - pad*2) * (1 - ((d.priceUSD - min)/(max-min)));
    return [x,y];
  });

  const path = pts.map((p,i)=> (i===0?`M ${p[0].toFixed(2)} ${p[1].toFixed(2)}`:`L ${p[0].toFixed(2)} ${p[1].toFixed(2)}`)).join(' ');
  const last = pts[pts.length-1];

  return `
    <svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none" aria-label="Price graph">
      <defs>
        <linearGradient id="g" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0%" stop-color="rgba(124,58,237,.9)"></stop>
          <stop offset="100%" stop-color="rgba(34,211,238,.8)"></stop>
        </linearGradient>
      </defs>
      <path d="${path}" fill="none" stroke="url(#g)" stroke-width="3" stroke-linecap="round"></path>
      <circle cx="${last[0].toFixed(2)}" cy="${last[1].toFixed(2)}" r="4" fill="rgba(231,238,252,.9)"></circle>
      <text x="${pad}" y="${h-pad}" fill="rgba(231,238,252,.55)" font-size="12" font-family="ui-monospace, monospace">
        min ${fmtMoney(min)} • max ${fmtMoney(max)}
      </text>
    </svg>
  `;
}

/** -----------------------------
 * Boot
 * ----------------------------- */
(function boot(){
  initSlots();
  renderTop();
  render();
  startSim();

  // ✅ mobile redirect handler (now async-safe)
  handlePhantomMobileRedirect();

  // Desktop silent reconnect only if user connected earlier in THIS TAB session.
  trySilentReconnect();
})();
</script>
</body>
</html>
