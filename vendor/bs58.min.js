/* Minimal bs58 (Base58) for browser use. Exposes window.bs58 = { encode(Uint8Array), decode(string) } */
(() => {
  const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const BASE = ALPHABET.length;
  const LEADER = ALPHABET[0];

  const MAP = new Uint8Array(256);
  MAP.fill(255);
  for (let i = 0; i < ALPHABET.length; i++) MAP[ALPHABET.charCodeAt(i)] = i;

  function encode(source) {
    if (!(source instanceof Uint8Array)) source = new Uint8Array(source);
    if (source.length === 0) return "";

    // Count leading zeros.
    let zeros = 0;
    while (zeros < source.length && source[zeros] === 0) zeros++;

    // Convert base256 -> base58 (classic base-x algorithm).
    const size = ((source.length - zeros) * 138 / 100 + 1) | 0; // log(256)/log(58)
    const b58 = new Uint8Array(size);

    let length = 0;
    for (let i = zeros; i < source.length; i++) {
      let carry = source[i];
      let j = 0;
      for (let k = size - 1; (carry !== 0 || j < length) && k >= 0; k--, j++) {
        carry += (256 * b58[k]) | 0;
        b58[k] = (carry % BASE) | 0;
        carry = (carry / BASE) | 0;
      }
      length = j;
    }

    // Skip leading zeros in base58 result.
    let start = size - length;
    while (start < size && b58[start] === 0) start++;

    let str = LEADER.repeat(zeros);
    for (let i = start; i < size; i++) str += ALPHABET[b58[i]];
    return str;
  }

  function decode(str) {
    if (typeof str !== "string") throw new Error("Expected base58 string");
    if (str.length === 0) return new Uint8Array(0);

    // Count leading leaders.
    let zeros = 0;
    while (zeros < str.length && str[zeros] === LEADER) zeros++;

    const size = ((str.length - zeros) * 733 / 1000 + 1) | 0; // log(58)/log(256)
    const b256 = new Uint8Array(size);

    let length = 0;
    for (let i = zeros; i < str.length; i++) {
      const ch = str.charCodeAt(i);
      const val = MAP[ch];
      if (val === 255) throw new Error("Non-base58 character");

      let carry = val;
      let j = 0;
      for (let k = size - 1; (carry !== 0 || j < length) && k >= 0; k--, j++) {
        carry += (BASE * b256[k]) | 0;
        b256[k] = (carry % 256) | 0;
        carry = (carry / 256) | 0;
      }
      length = j;
    }

    let start = size - length;
    while (start < size && b256[start] === 0) start++;

    const out = new Uint8Array(zeros + (size - start));
    out.fill(0, 0, zeros);
    out.set(b256.slice(start), zeros);
    return out;
  }

  window.bs58 = { encode, decode };
})();
